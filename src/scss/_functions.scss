// Utilities
// -----------------------------------------------------------------------------

// Convert any CSS <length> or <percentage> value to any another.
//
// @param {Number} $length
//  A css <length> or <percentage> value
//
// @param {String} $to-unit
//  String matching a css unit keyword, e.g. 'em', '%', etc.
//
// @param {Number} $from-context
//  When converting from relative units, the absolute length (in px) to
//  which $length refers (e.g. for $length with em units, would normally
//  be the font-size of the current element).
//  16px is typically default font-size for all browsers.
//
// @param {Number} $to-context
//  For converting to relative units, the absolute length in px to which the
//  output value will refer. Defaults to the same as $from-context, since it
//  is rarely needed.
//
// @return {Number}
//  Converted CSS length
//
@function convert-length($length, $to-unit, $from-context: 16px, $to-context: $from-context) {

	$from-unit: unit($length);

	// Optimize for cases where `from` and `to` units are accidentally the same.
	@if $from-unit == $to-unit {
		@return $length;
	}

	// Context values must be in px so we can determine a conversion ratio for
	// relative units.
	@if unit($from-context) != 'px' {
		@warn 'Paremeter "$from-context #{$from-context}" must resolve to a value in pixel units.';
	}
	@if unit($to-context) != 'px' {
		@warn 'Parameter "$to-context #{$to-context}" must resolve to a value in pixel units.';
	}

	// Convert input length to pixels
	$px-length: $length;

	@if $from-unit != 'px' {
		// Convert relative units using the from-context parameter.
		@if $from-unit == 'em' {
			$px-length: $length * $from-context / 1em;
		} @else if $from-unit == 'rem' {
			$px-length: $length * $from-context / 1rem;
		} @else if $from-unit == '%' {
			$px-length: $length * $from-context / 100%;
		} @else if $from-unit == 'ex' {
			$px-length: $length * $from-context / 2ex;
		} @else if $from-unit == 'in' or $from-unit == 'mm' or $from-unit == 'cm' or $from-unit == 'pt' or $from-unit == 'pc' {
			// Convert absolute units using SASS conversion table.
			$px-length: 0px + $length;
		} @else if $from-unit == 'ch' or $from-unit == 'vw' or $from-unit == 'vh' or $from-unit == 'vmin' {
			// Certain units can't be converted.
			@warn '#{$from-unit} units can\'t be reliably converted. Returning original value.';
			@return $length;
		} @else {
			@warn '#{$from-unit} is an unknown length unit. Returning original value.';
			@return $length;
		}
	}

	// Convert length in pixels to the output unit
	$output-length: $px-length;

	@if $to-unit != 'px' {
		@if $to-unit == 'em' {
			$output-length: $px-length * 1em / $to-context;
		} @else if $to-unit == 'rem' {
			$output-length: $px-length * 1rem / $to-context;
		} @else if $to-unit == '%' {
			$output-length: $px-length * 100% / $to-context;
		} @else if $to-unit == 'ex' {
			$output-length: $px-length * 2ex / $to-context;
		} @else if $to-unit == 'in' {
			$output-length: 0in + $px-length;
		} @else if $to-unit == 'mm' {
			$output-length: 0mm + $px-length;
		} @else if $to-unit == 'cm' {
			$output-length: 0cm + $px-length;
		} @else if $to-unit == 'pt' {
			$output-length: 0pt + $px-length;
		} @else if $to-unit == 'pc' {
			$output-length: 0pc + $px-length;
		} @else if $to-unit == 'ch' or $to-unit == 'vw' or $to-unit == 'vh' or $to-unit == 'vmin' {
			// Non-convertible units
			@warn '#{$to-unit} units can\'t be reliably converted. Returning original value.';
			@return $length;
		} @else {
			@warn '#{$to-unit} is an unknown length unit. Returning original value.';
			@return $length;
		}
	}

	@return $output-length;
}

// Returns the value in rem for a given value.
//
// @param {Number} $value
//  The value to be converted.
//
// @return {Number}
//  The converted value in rem.
//
@function rem($value, $from-context: 16px) {
	@return convert-length($value, 'rem');
}

// Returns the value in px for a given value.
//
// @param {Number} $value
//  The value to be converted.
//
// @return {Number}
//  The converted value in px.
//
@function px($value) {
	@return convert-length($value, 'px');
}

// Returns the value in em for a given value.
//
// @param {Number} $value
//  The value to be converted.
//
// @return {Number}
//  The converted value in em.
//
@function em($value) {
	@return convert-length($value, 'em');
}

// Convert string to number if string is valid CSS <length>.
// Casts a string into a number
//
// @param {String|Number} $string
//   Value to be parsed
//
// @return {Number}
//
@function to-number($string) {

	// $string: if(type-of($string) == string, unquote($string), $string);

	@if type-of($string) == number {
		@return $string;
	} @else if type-of($string) == string {

		$result: 0;
		$digits: 0;
		$minus: str-slice($string, 1, 1) == '-';
		$numbers: (
			'0': 0,
			'1': 1,
			'2': 2,
			'3': 3,
			'4': 4,
			'5': 5,
			'6': 6,
			'7': 7,
			'8': 8,
			'9': 9
		);

		@for $i from if($minus, 2, 1) through str-length($string) {

			$character: str-slice($string, $i, $i);

			@if not (index(map-keys($numbers), $character) or $character == '.') {
				@return add-unit(if($minus, -$result, $result), str-slice($string, $i));
			}

			@if $character == '.' {
				$digits: 1;
			} @else if $digits == 0 {
				$result: $result * 10 + map-get($numbers, $character);
			} @else {
				$digits: $digits * 10;
				$result: $result + map-get($numbers, $character) / $digits;
			}
		}

		@return if($minus, -$result, $result);

	} @else {
		@warn 'Value for "$string: #{$string}" should be a number or a string.';
		@return $string;
	}
}

// Remove the unit of a CSS <length>.
//
// @param {Number} $length
//   Number to remove unit from
//
// @return {Number}
//   Unitless number
//
@function strip-unit($number) {
	@if type-of($number) == 'number' {
		@if unitless($number) == false {
			@return $number / ($number * 0 + 1);
		}
	} @else {
		@warn '"$number: #{$number}" is #{type-of($number)} value and must resolve to a number value.';
	}
	@return $number;
}

// Add $unit to $unitless-number.
//
// @param {Number} $unitless-number
//   Value to add unit to
//
// @param {String} $unit
//   String representation of the unit
//
// @return {Number}
//   $unitless-number expressed in $unit
//
@function add-unit($unitless-number, $unit) {
	$units: (
		'px': 1px,
		'cm': 1cm,
		'mm': 1mm,
		'%': 1%,
		'ch': 1ch,
		'pc': 1pc,
		'in': 1in,
		'em': 1em,
		'rem': 1rem,
		'pt': 1pt,
		'ex': 1ex,
		'vw': 1vw,
		'vh': 1vh,
		'vmin': 1vmin,
		'vmax': 1vmax
	);
	@if index(map-keys($units), $unit) {
		@return $unitless-number * map-get($units, $unit);
	}
	@warn 'Invalid unit "#{$unit}".';
}

// Returns the list of available names in a given map.
//
// @param {Map} $map
//  The map of data to list the names from.
//
// @param {Number} $map
//  The level of depth to get names from.
//
// @return {String}
//  The list of names in the map.
//
@function available-names($map, $level: 1) {
	@if type-of($map) != 'map' {
		@return null;
	}

	$output: '';
	$newline: '\A ';

	@if $level == 1 {
		@each $key, $value in $map {
			$output: $output + '#{$newline}- #{$key} #{available-names($value, $level + 1)}';
		}
	} @else {
		$output: '(';
		$i: 1;

		@each $key, $value in $map {
			$sep: if($i < length($map), ', ', '');
			$output: $output + '#{$key}#{$sep}#{available-names($value, $level + 1)}';
			$i: $i + 1;
		}

		$output: $output + ')';
	}
	@return $output;
}

// Merge multiple maps into one.
//
// @param {Map} $map
//  Initial default map.
//
// @param {ArgList} $maps
//  Other maps to merge.
//
// @return {Map}
//  The final merged map.
//
@function map-extend($map, $maps...) {
	@for $i from 1 through length($maps) {
		@each $key, $value in nth($maps, $i) {
			$map: map-merge(
				$map,
				(
					$key: $value,
				)
			);
			@if (type-of($value) == map) and (type-of(map-get($map, $key)) == map) {
				$value: map-extend(map-get($map, $key), $value);
			}
		}
	}
	@return $map;
}

// Fetch nested keys
//
// @param {Map} $map
//  Map
//
// @param {Arglist} $keys
//  Keys to fetch
//
// @return {*}
//
@function map-deep-get($map, $keys...) {
	@each $key in $keys {
		$map: map-get($map, $key);
	}
	@return $map;
}

// Update a key deeply nested
//
// @param {Map} $map
//  Map to update
//
// @param {Arglist} $keys
//  Keys to access to value to update
//
// @param {*} $value
//  New value (last member of `$keys`)
//
// @return {Map}
//  Updated map
//
@function map-deep-set($map, $keys.../*, $value */) {
	$map-list: ($map,);
	$result: null;

	@if length($keys) == 2 {
		@return map-merge($map, (nth($keys, 1): nth($keys, -1)));
	}
	@for $i from 1 through length($keys) - 2 {
		$map-list: append($map-list, map-get(nth($map-list, -1), nth($keys, $i)));
	}
	@for $i from length($map-list) through 1 {
		$result: map-merge(nth($map-list, $i), (nth($keys, $i): if($i == length($map-list), nth($keys, -1), $result)));
	}
	@return $result;
}

// Math functions require for moudlar type scale.
//
@function pow($number, $exponent) {
	@if (round($exponent) != $exponent) {
		@return exp($exponent * ln($number));
	}
	$value: 1;
	@if $exponent > 0 {
		@for $i from 1 through $exponent {
			$value: $value * $number;
		}
	} @else if $exponent < 0 {
		@for $i from 1 through -$exponent {
			$value: $value / $number;
		}
	}
	@return $value;
}
@function factorial($value) {
	$result: 1;
	@if $value == 0 {
		@return $result;
	}
	@for $index from 1 through $value {
		$result: $result * $index;
	}
	@return $result;
}
@function summation($iteratee, $input, $initial: 0, $limit: 100) {
	$sum: 0;
	@for $index from $initial to $limit {
		$sum: $sum + call(get-function($iteratee), $input, $index);
	}
	@return $sum;
}
@function exp-maclaurin($x, $n) {
	@return (pow($x, $n) / factorial($n));
}
@function exp($value) {
	@return summation('exp-maclaurin', $value, 0, 100);
}
@function ln-maclaurin($x, $n) {
	@return (pow(-1, $n + 1) / $n) * (pow($x - 1, $n));
}
@function ln($value) {
	$ten-exp: 1;
	$ln-ten: 2.30258509;
	@while ($value > pow(10, $ten-exp)) {
		$ten-exp: $ten-exp + 1;
	}
	@return summation(ln-maclaurin, $value / pow(10, $ten-exp), 1, 100) + $ten-exp * $ln-ten;
}

// Typography and Baseline
// -----------------------------------------------------------------------------

// Returns font size based on modular type scale.
//
// @param {Number} $font-size
//  Step to use in calculation
//
// @param {String} $unit
//  Unit in which value should be return
//
// @param {Number} $from-context
//  When converting from relative units, the absolute length (in px) to
//  which $font-size refers (e.g. for $font-sizes in em units, would
//  normally be the font-size of the current element).
//
// @param {String|false} $round-function
//  Round function to use.
//
@function font-size($font-size: 0, $unit: rem, $from-context: 0, $round-function: false) {

	@if unit($font-size) != number and unitless($font-size) == false {
		@warn 'Paremeter "$font-size #{$font-size}" must resolve to a unitless number.';
	} @else {
		$font-size: pow($type-scale-ratio, $font-size) * $base-font-size;
	}

	@if unit($from-context) != number and unitless($from-context) == false {
		@warn 'Paremeter "$from-context #{$from-context}" must resolve to a unitless number.';
	} @else {
		$from-context: pow($type-scale-ratio, $from-context) * $base-font-size;
	}

	@if $round-function == round {
		// Round a number to the nearest whole number.
		$font-size: round($font-size);
		$from-context: round($from-context);
	} @else if $round-function == ceil {
		// Round a number up to the next whole number.
		$font-size: ceil($font-size);
		$from-context: ceil($from-context);
	} @else if $round-function == floor {
		// Round a number down to the previous whole number.
		$font-size: floor($font-size);
		$from-context: floor($from-context);
	}

	@return convert-length($font-size, $unit, $from-context);
}

// Returns baseline (vertical rhythm) values.
//
// @param {Number} $lines
//
// @param {String} $unit
//  Unit in which value should be return
//
// @param {Number} $from-context
//  When converting from relative units, the absolute length (in px) to
//  which $font-size refers (e.g. for $font-sizes in em units, would
//  normally be the font-size of the current element).
//
// @param {Boolean} $unitless-zero
//  Wheather return unitless zero values or zero with the default unit
//
@function baseline($lines: 1, $unit: rem, $from-context: 0, $unitless-zero: false) {

	$from-context: font-size($from-context, px);

	$return: ();

	@each $line in $lines {

		$to-join: $line;

		@if type-of($line) == number and unitless($line) {

			$value: $line * $base-line-height;
			$to-join: convert-length($value, $unit, $from-context);

		} @else if type-of($line) == string and str-index($line, ':') {

			$l: str-slice($line, 1, str-index($line, ':') - 1);
			$l: to-number($l);

			$o: str-slice($line, str-index($line, ':') + 1);
			$o: to-number($o);

			$value: 0;

			@if type-of($l) == number and unitless($l) {

				$value: $l * $base-line-height;
				$value: convert-length($value, $unit, $from-context);

			} @else {
				$value: convert-length($l, $unit, $from-context);
			}

			$offset: convert-length($o, $unit, $from-context);

			$to-join: $value + $offset;
		}

		@if $unitless-zero and number == type-of($to-join) and 0 == $to-join {
			$return: join($return, 0);
		} @else {
			$return: join($return, $to-join);
		}
	}

	// Return a calulated single value or list of values.
	@if length($return) == 1 {
		@return nth($return, 1);
	}

	@return $return;
}

// Layout
// -----------------------------------------------------------------------------

// Get a breakpoint's width
//
// @param {String} $name
//  Name of the breakpoint. One of $breakpoints-data
//
// @example scss
//  $tablet-width: breakpoint(tablet);
//  @media (min-width: breakpoint(desktop)) {}
//
// @requires {Variable} $breakpoint-data
//
// @returns {Number} Value in specified unit.
//
@function breakpoint($name, $unit: $media-query-unit) {
	@if map-has-key($breakpoint-data, $name) {
		$width: map-get($breakpoint-data, $name);
		@return convert-length($width, $unit);
	}
	@error '\a Breakpoint `#{$name}` not found.\a\a Available options: #{available-names($breakpoint-data)}\a\a';
}

// Colors
// -----------------------------------------------------------------------------

// Returns the color value for a given color name and group.
//
// @param {String} $color
//  The color’s hue.
//
// @param {String} $variation
//  The darkness/lightness of the color.
//
// @param {Color} $for-background
//  The background color on which this color will appear. Applies a multiply
//  filter to ensure appropriate contrast.
//
// @return {Color} The color value.
//
@function color($color, $variation: null, $for-background: null) {
	$fetched-color: false;
	@if map-has-key($color-data, $color) {
		$fetched-hue: map-get($color-data, $color);
		@if $variation == null {
			@if $fetched-hue == null {
				@return null;
			} @elseif type-of($fetched-hue) == color {
				$fetched-color: $fetched-hue;
			} @elseif map-has-key($fetched-hue, base) {
				$fetched-color: map-get($fetched-hue, base);
			} @elseif map-has-key($fetched-hue, '500') {
				$fetched-color: map-get($fetched-hue, '500');
			}
		} @elseif type-of($fetched-hue) == map {
			$variation: quote($variation);
			@if map-has-key($fetched-hue, $variation) {
				$fetched-color: map-get($fetched-hue, $variation);
			}
		}
	}
	@if type-of($fetched-color) == color {
		@if $for-background != null {
			$fetched-color: color-multiply($fetched-color, $for-background);
		}
		@return $fetched-color;
	} @else {
		@error "\a Color `#{$color}#{if($variation, ' (' + $variation + ')', '')}` not found.\a\a Available options: #{available-names($color-data)}\a\a";
	}
}

// Darkens the foreground color by the background color. This is the same as
// the "multiply" filter in graphics apps.
//
// @param {Color} $foreground
//  The color to darken.
//
// @param {Color} $background
//  The background to base darkening on.
//
// @return {Color} The modified color.
//
@function color-multiply($foreground, $background: null) {
	@if $background == null {
		$background: rgb(255, 255, 255);
	}

	$red: red($background) * red($foreground) / 255;
	$green: green($background) * green($foreground) / 255;
	$blue: blue($background) * blue($foreground) / 255;

	$opacity: opacity($foreground);
	$background-opacity: opacity($background);

	// Calculate opacity
	$bm-red: $red * $opacity + red($background) * $background-opacity * (1 - $opacity);
	$bm-green: $green * $opacity + green($background) * $background-opacity * (1 - $opacity);
	$bm-blue: $blue * $opacity + blue($background) * $background-opacity * (1 - $opacity);

	@return rgb($bm-red, $bm-green, $bm-blue);
}

// Borders
// -----------------------------------------------------------------------------

// Returns the width of the specified border type.
//
// @param {String} $element
//  The border element key.
//
// @return {Number}
//  The width for the border.
//
@function border-width($element) {
	$fetched-value: map-get($border-width-data, $element);

	@if type-of($fetched-value) == number {
		@return $fetched-value;
	} @else {
		@error 'Border width element `#{$element}` not found.\a\a  Available elements: #{available-names($border-width-data)}\a\a';
	}
}

// Returns the border radius of the specified size.
//
// @param {String} $size
//  The border radius’s size.
//
// @return {Number}
//  The border radius value.
//
@function border-radius($size) {
	$fetched-value: map-get($border-radius-data, $size);

	@if type-of($fetched-value) == number {
		@return $fetched-value;
	} @else {
		@error 'Border radius size `#{$size}` not found.\a\a Available variants: #{available-names($border-radius-data)}\a\a';
	}
}

// Height
// -----------------------------------------------------------------------------

// Returns the baseline height of the specified element.
//
// @param {String} $element
//  The height’s element.
//
// @return {Number}
//  The baseline height value.
//
@function height($element) {
	$fetched-value: map-get($height-data, $element);

	@if type-of($fetched-value) == number {
		@return $fetched-value;
	} @else {
		@error 'element `#{$element}` not found.\a\a Available variants: #{available-names($height-data)}\a\a';
	}
}

// Duration
// -----------------------------------------------------------------------------

// Returns the duration value for a given variant.
//
// @param {String} $variant - The key for the given variant.
// @return {Number} The duration for the variant (in miliseconds).
//
@function duration($variant) {
	$fetched-value: map-get($duration-data, $variant);

	@if type-of($fetched-value) == number {
		@return $fetched-value;
	} @else {
		@error 'Duration variant `#{$variant}` not found.\a\a Available variants: #{available-names($duration-data)}\a\a';
	}
}

// Easing
// -----------------------------------------------------------------------------

// Returns the timing-function value for a given variant.
//
// @param {String} $variant
//  The key for the given variant.
//
// @return {String}
//  The cubic-bezier function (string) for the variant.
//
@function easing($variant) {
	$fetched-value: map-get($easing-data, $variant);

	@if type-of($fetched-value) == string {
		@return $fetched-value;
	} @else {
		@error 'Easing variant `#{$variant}` not found.\a\a Available variants: #{available-names($easing-data)}\a\a';
	}
}

// Shadows
// -----------------------------------------------------------------------------

// Returns the shadow for the specified depth
//
// @param {String} $depth
//  The shadow’s depth.
//
// @return {List}
//  The shadow value.
//
@function shadow($depth) {
	$fetched-value: map-get($shadow-data, $depth);

	@if type-of($fetched-value) == list {
		@return $fetched-value;
	} @else {
		@error 'Shadow variant `#{$depth}` not found.\a\a Available variants: #{available-names($shadow-data)}\a\a';
	}
}

// Typography
// -----------------------------------------------------------------------------

// Returns the font stack for a given family.
//
// @param {String} $family
//  The key for the given family.
//
// @return {Number}
//  The font stack for the family.
//
@function font-family($family) {
	$fetched-value: map-get($font-family-data, $family);

	@if $fetched-value != null {
		@return $fetched-value;
	} @else {
		@error 'Font family `#{$family}` not found.\a\a Available font families: #{available-names($font-family-data)}\a\a';
	}
}

// Returns the font weight for a given family.
//
// @param {String} $family
//  The key for the given family.
//
// @return {Number}
//  The font weight for the family.
//
@function font-weight($family) {
	$fetched-value: map-get($font-weight-data, $family);

	@if $fetched-value != null {
		@return $fetched-value;
	} @else {
		@error 'Font weight `#{$family}` not found.\a\a Available font families: #{available-names($font-weight-data)}\a\a';
	}
}

// Z-index
// -----------------------------------------------------------------------------

// Returns the z-index of the specified element.
//
// @param {String} $element
//  The key for the element.
//
// @param {Map} $context
//  The map in which to search for the element.
//
// @return {Number}
//  The z-index for the element.
//
@function z-index($element) {
	$index: map-get($z-index-data, $element);

	@if $index {
		@return $index;
	} @else {
		@error 'z-index `#{$element}` in `#{$z-index-data}` not found.';
	}
}
